<!DOCTYPE html>
<html>
<head>
  <title>WebRTC RTSP Viewer</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h3>Stream tá»« GStreamer</h3>
  <video id="video" autoplay playsinline controls></video>

  <div id="stats">
    <p><strong>Latency:</strong> <span id="latency">-</span> ms</p>
    <p><strong>FPS:</strong> <span id="fps">-</span></p>
    <p><strong>Bitrate:</strong> <span id="bitrate">-</span> kbps</p>
    <p><strong>CPU:</strong> <span id="cpu">-</span>%</p>
    <p><strong>RAM:</strong> <span id="ram">-</span> MB</p>
  </div>

  <script>
    const video = document.getElementById("video");
    const ws = new WebSocket("ws://127.0.0.1:8080/ws");

    const pc = new RTCPeerConnection({
      iceServers: []
    });

    let frames = 0;
    let lastFrameTime = performance.now();
    let lastBytesReceived = 0;
    let lastBitrateTimestamp = performance.now();

    // FPS báº±ng requestAnimationFrame
    function updateFPS() {
      frames++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000) {
        const fps = frames;
        document.getElementById("fps").innerText = fps;
        frames = 0;
        lastFrameTime = now;
      }
      requestAnimationFrame(updateFPS);
    }
    requestAnimationFrame(updateFPS);

    // Gá»­i ICE vá» server
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        ws.send(JSON.stringify({
          type: "ice",
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          candidate: event.candidate.candidate
        }));
      }
    };

    // Nháº­n track media
    pc.ontrack = (event) => {
      console.log("ðŸ“º Received track:", event.track.kind);
      if (event.streams[0].getVideoTracks().length > 0) {
        video.srcObject = event.streams[0];
        video.onloadedmetadata = () => {
          video.play().catch(e => console.error("ðŸ”´ Play failed:", e));
        };
      }
    };

    // WebSocket nháº­n SDP hoáº·c ICE
    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);

      if (msg.type === "sdp") {
        console.log("ðŸ“¥ Received SDP offer");
        await pc.setRemoteDescription(new RTCSessionDescription({
          type: "offer",
          sdp: msg.sdp
        }));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
          type: "sdp",
          sdp: answer.sdp
        }));

        // Báº¯t Ä‘áº§u thu thá»‘ng kÃª sau khi káº¿t ná»‘i
        startStatsCollection();
      } else if (msg.type === "ice") {
        console.log("ðŸ“¥ Received ICE candidate");
        try {
          const candidate = new RTCIceCandidate({
            candidate: msg.candidate,
            sdpMLineIndex: msg.sdpMLineIndex,
          });
          await pc.addIceCandidate(candidate);
        } catch (e) {
          console.error("âŒ Error adding ICE candidate:", e);
        }
      }
    };

    ws.onopen = () => {
      console.log("âœ… WebSocket connected.");
    };

    // Láº¥y thá»‘ng kÃª WebRTC + RAM/CPU
    function startStatsCollection() {
      setInterval(async () => {
        const stats = await pc.getStats(null);
        stats.forEach(report => {
          if (report.type === "inbound-rtp" && report.kind === "video") {
            if (report.framesPerSecond)
              document.getElementById("fps").innerText = report.framesPerSecond.toFixed(1);

            if (report.roundTripTime)
              document.getElementById("latency").innerText = (report.roundTripTime * 1000).toFixed(2);

            // Bitrate calculation
            if (typeof report.bytesReceived !== "undefined") {
              const now = performance.now();
              if (lastBytesReceived !== 0) {
                const bytes = report.bytesReceived - lastBytesReceived;
                const duration = (now - lastBitrateTimestamp) / 1000; // seconds
                if (duration > 0) {
                  const bitrateKbps = ((bytes * 8) / 1000 / duration).toFixed(1);
                  document.getElementById("bitrate").innerText = bitrateKbps;
                }
              }
              lastBytesReceived = report.bytesReceived;
              lastBitrateTimestamp = now;
            }
          }
        });

        // RAM (chá»‰ Chrome)
        if (performance.memory) {
          const ramUsedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
          document.getElementById("ram").innerText = ramUsedMB;
        } else {
          document.getElementById("ram").innerText = "N/A";
        }

        // CPU sÆ¡ bá»™ (dá»±a trÃªn sá»‘ frame cáº­p nháº­t má»—i giÃ¢y)
        const cpuLoad = Math.min(100, Math.round((frames / 60) * 100));
        document.getElementById("cpu").innerText = cpuLoad;
      }, 1000);
    }
  </script>
</body>
</html>

